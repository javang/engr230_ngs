
import MetagenomeDatabase
import BLASTUtilities
import os
import re
import subprocess
import logging
import paranoid_log
log = logging.getLogger("ClaMSUtilities")

class ClaMSRunner:
    """ Class to call the ClaMS program
    """

    def __init__(self, k=4, threshold=0.1):
        """
            @param k Size of the k-mers used to compare the de Bruijn signatures
            @param threshold threshold distance to provide to ClaMS
        """
        self.k = k
        self.threshold = threshold


    def run(self, fn_input, fn_references, fn_output):
        """
            run the ClaMS program to compare the de Bruijn chain signatures between
            a query sequence and a set of reference sequences
            @param fn_input FASTA input file with input sequences
            @param fn_references File containing two columns: The first is an identifier and the
                   second is the file containing the sequence of the identifier
            @param fn_output Output file generated by ClaMS, with the distances between Kmer
            signatures of the inputs and references.
        """
        log.info("Running ClaMS for file %s with references %s", fn_input, fn_references)
        import config
        p = config.ConfigVariables.path_ClaMS
        clams = os.path.join(p,"ClaMS-CLI.jar")
        command = "java -jar {0} {1} {2} {3} DBC {4} {5}".format(clams,
                      fn_references, fn_input, fn_output, self.k, self.threshold)
        # Popen does not like a string, I have to split in the whitespaces
        process_id = subprocess.Popen(command.split(" "),shell=False,env=os.environ,
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err) = process_id.communicate()
        if err != "":
            msg = "There was an error runngin ClaMS for {0}: {1}".format(fn_input, err)
            log.error( msg)
            return False
            raise IOError(msg)
        log.debug("Returning: %s",fn_output)
        return fn_output


def write_genera_sequences(fn_database, fn_output, directory="genera_sequences"):
    """ Puts all the scaffolds assigned to a genus together and writes the sequence.

        The function reads the database to recover the genus given each of the assigned
        scaffolds. Scaffolds having the same genus are concatenated. The concatenated
        frankenstein sequences can be used to calculate k-mer signatures for each of the
        genusus.
        The frankenstein sequence of each of the genera is written to a fasta file.

        @param fn_database Database file
        @param fn_output Output file containing two columns: The first is the genus and the
               second is the file containing it sequence
        @param directory Directory used to store the files with the sequences of the genera_sequences
    """

    db = MetagenomeDatabase.MetagenomeDatabase(fn_database)
    genus2sequence_dict, assigned_scaffolds = db.get_genera_sequences()
    # directory for storing the sequences of each of the genera
    curdir = os.getcwd()
    if not os.path.exists(directory):
        os.mkdir(directory)
    os.chdir(os.path.join(curdir,directory))
    for genus in genus2sequence_dict:
        fn = os.path.join(directory, "{0}.fasta".format(genus))
        fh.write("{0}\t{1}\n".format(genus,fn))
        log.debug("Writting %s", fn)
        BLASTUtilities.write_fasta_file(genus, genus2sequence_dict[genus], fn)
    fh.close()
    os.chdir(curdir)

def read_clams_results(fn):
    """ Read the results of the assignments from ClaMS
        @param fn File containing the results
        @return A dictionary. The keys of the dictionary are the
        names of the scaffolds. The values are in the dictionary are
        the pairs (genus, ClaMS distance) for each scaffold.
    """
    pattern = re.compile(".*?\:\s+(.*?)\s+(.*?)\s+([0-9\.]+)")
    assignments = dict()
    for line in open(fn):
        m = re.match(pattern,line)
        if m:
            assignments[m.group(1)] = (m.group(2), m.group(3))
    return assignments
